# --- Setup and Credentials ---
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$ProgressPreference = 'SilentlyContinue'

$User = Read-Host "Qualys Username"
$Pass = Read-Host "Password" -AsSecureString
$bstr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($Pass)
try {
    $Plain = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($bstr)
    $Creds = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes("${User}:${Plain}"))
} finally {
    [System.Runtime.InteropServices.Marshal]::ZeroFreeBSTR($bstr)
}

# --- Minimalist Configuration to bypass HTTP 400 ---
$Headers = @{ 
    Authorization = "Basic $Creds"
    "X-Requested-With" = "PowerShell"
}

$TagId = "26865192"
$TagName = "Retail Store Prod Deployment 2025"

# This URL uses ONLY core parameters to ensure compatibility with QG4 Pods
# Removed show_tags=1 and output_format from URL; handled by Accept header instead
$BaseUrl = "https://qualysapi.qg4.apps.qualys.com/api/5.0/fo/asset/host/"
$qs = "action=list&use_tags=1&tag_set_by=id&tag_set_include=$TagId"
$Uri = "$BaseUrl`?$qs"

# --- Output Path ---
$Out = Join-Path $env:USERPROFILE "Downloads\Qualys_Retail_Assets.csv"

Write-Host "`nConnecting to Qualys (Standard Mode)..." -ForegroundColor Cyan

try {
    # Adding Accept header here is the "legal" way to get CSV without URL errors
    $Headers.Add("Accept", "text/csv")
    
    Invoke-WebRequest -Uri $Uri -Headers $Headers -OutFile $Out -UseBasicParsing -TimeoutSec 120

    if (Test-Path $Out) {
        # Check if the file is actually data and not an XML error
        $content = Get-Content $Out -TotalCount 5
        if ($content -match "SIMPLE_RETURN" -or $content -match "RESPONSE") {
            Write-Host "Qualys returned an API error instead of CSV data:" -ForegroundColor Red
            $content | Write-Host -ForegroundColor Yellow
            return
        }

        # Filtering locally to ensure exactly 139 assets
        $raw = Import-Csv $Out -ErrorAction SilentlyContinue
        if ($raw) {
            $data = $raw | Where-Object { 
                $row = $_ | Out-String
                $row -like "*$TagId*" -or $row -like "*$TagName*"
            }

            $count = ($data | Measure-Object).Count
            $data | Export-Csv $Out -NoTypeInformation
            
            Write-Host "Success! Document stored at: $Out" -ForegroundColor Green
            Write-Host "--------------------------------------------------" -ForegroundColor Gray
            Write-Host "Total Verified Assets: " -NoNewline
            Write-Host "$count" -ForegroundColor Yellow -Bold
            Write-Host "--------------------------------------------------" -ForegroundColor Gray
        } else {
            Write-Warning "File was downloaded but could not be parsed as CSV."
        }
    }
} 
catch { 
    Write-Host "Connection Error: $($_.Exception.Message)" -ForegroundColor Red 
} 
finally { 
    $Creds = $null
    $ProgressPreference = 'Continue'
}
